# 创建高性能的索引 2

## 高性能的索引策略
### 独立的列 
以下两个错误的语句,需要始终将索引列单独放在比较符号的一侧

```sql
SELECT actor_id FROM dskils.actor WHERE actor.id + 1 = 5;

SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;
```

### 前缀索引和索引的选择性
> 有时候需要索引很长的字符列,这会让索引变得大且慢.一个策略是前面提到过的模拟哈希索引.但有时候还不够

&emsp;&emsp;通常可以索引开始的部分字符,这样可以大大节约索引空间,提高索引效率.但是这样也会降低索引的选择性(cardinality).索引的选择性越高查询效率越高,唯一索引的选择性最高为1.

&emsp;&emsp;一般情况下,某个列前缀的选择性也是足够高的,足以满足查询性能.但是对于 BLOB,TEXT 或者很长的 VARCHAR 类型的列,必须使用前缀索引,因为MySQL 不允许索引这些列的完整长度.

&emsp;&emsp;诀窍在于要选择足够长的前缀索引以保证较高的选择性,同事又不能太长(节约空间).前缀应该足够长,以使得前缀索引的选择性接近于索引的整个列.

计算合适的前缀长度的另外一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。下面展示如何计算完整列的选择性：



### 多列索引
#### 选择合适的索引列顺序
当不需要考虑排序和分组时,最好将选择性最高的列放到索引的最前列.具体的可以测试得出.

#### 聚簇索引
聚簇索引并不是一种单独的索引类型,而是一种数据存储方式.InnoDB 的聚簇索引实际上在同一结构中保存了 B-Tree 索引和数据行.

当表有聚簇索引时,他的数据行实际上存放在索引的叶子页中.术语"聚簇"表示数据行和相邻的兼职紧凑的存储在一起.因为无法同时把数据行存放在两个不同的地方,所以一个表只有一个聚簇索引(不过覆盖索引可以模拟多个聚簇索引的情况).

聚集的数据有以下重要的优点:

- 可以把相关的数据保存在一起.
- 数据访问更快.因为聚簇索引将索引和数据存放在用一个 B-Tree 中.
- 使用覆盖索引扫描的查询可以直接使用节点中的主键值

也有以下缺点:

- 聚簇索引可以提高 I/O 的性能.如果将数据全部放在内存中将没有使用聚簇索引的必要.
- 插入速度严重依赖插入顺序.
- 更新聚簇索引的代价很高.
- 基于聚簇索引的表在插入新行,或者主键被更新需要移动行的时候可能面临叶分裂的问题.叶分裂会导致表占用更多的磁盘空间
- 聚簇索引可能导致全表扫描变慢
- 二级索引可能比想象的更大
- 二级索引访问需要两次索引查找,而不是一次

#### 覆盖索引
> 如果索引的叶子节点中已经包含要查询的数据,那么还有什么必要再回表查询呢?**如果一个索引包含(或者说覆盖)所有需要查询的字段的值,我们就称为覆盖索引.**  

覆盖索引有以下优点:

- 索引条目通常远小于数据行大小，所以如果只需要读取索引，就极大的减少数据访问量。这对MyISAM尤其正确，因为MyISAM能压缩索引以变得更小.
- 因为索引是按照顺序存储的(单页)，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少很多
- 由于InnoDB的聚簇索引，覆盖索引对InnoDB特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询

**覆盖索引必须要存储索引列的值，而哈希索引、空间索引、和全文索引都不能存储列的值，所以MySQL只能使用B-Tree索引做覆盖索引.**

当发起一个索引覆盖的查询时，在EXPLAIN的Extra列可以看到Usingindex的信息,另外需要注意触发覆盖索引的条件

#### 使用索引来做排序
MySQL 有两种方式可以生成有序的结果:通过排序操作;或者按索引顺序扫描;如果 EXPLAIN 出来的 type 的值为 index, 则说明 MYSQLS使用了索引扫描来做排序.


